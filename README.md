This is another project that I designed to practice coding in R. Sudoku puzzles mainly revolve around logic narrowing down potential solutions, so this was a great project to learn about matrices in R, some basic functions involving strings and combinatorics, and compacting otherwise repetitive code. Currently, the only way for the code to solve a sudoku puzzle is to have a vector that lists every square in the sudoku board, with 0's in the empty slots. In the future, I will try to make the code compatible with a CSV file, or something that will try to minimize the time spent creating the original sudoku puzzle.

# Sudoku Setup

A standard sudoku board gives a 9x9 grid, with some of the spots filled in with numbers. The goal is to use these clues to fill in the rest of the board such that every row, column, and sectioned off 3x3 grid contains the numbers 1-9 without repeats. Once the sudoku board has been created as a matrix in R, it converts the matrix into a character matrix and replaces the 0 values with a string of numbers 1-9. The idea is that these functions will use the properties of sudoku puzzles to eliminate possible numbers in each of the boxes. So, if the number 9 cannot appear in a box because there is already a 9 in the same row, these functions will get rid of the 9 from that box's string, leaving the numbers 1-8 in that spot for the matrix. Now that the puzzle is set up in this way, it will go through 4 tiers of solving methods to try to find the solution. If a puzzle is solved in tier 3, for example, then the program will skip the process for tier 4.

# Functions

## Tier 1

Tier 1 solving utilizes the principals of sudoku puzzles. Since each row, column, and 3x3 grid must contain 1-9, it goes through and eliminates the conflicts within each row, column, and grid. If there is already a number in one of these subsections (such as a row, column, or grid), such as 4, then it goes through that subsection and removes all other instances of the number 4, since a 4 can't go anywhere else in that subsection. Tier 1 also goes through the subsections and checks if there is a number that can only go in one spot. If there is a row where a 6 can only go in one spot, it does not matter what else can go in that spot, because the row needs a 6, so it must go there.

## Tier 2

Tier 2 relates the properties of rows and columns with the properties of 3x3 grids. If the number 1 is needed in a row, but the only places the 1 could go is in a single 3x3 grid, then a 1 cannot go anywhere else in that grid other than those spots. The logic works in reverse as well. If a box needs a 7, but it can only go in a couple of spots that share a column, then the 7 has to be in those spots in that column, and a 7 cannot appear anywhere else in that column. To do this in R, it looks at each number in a subsection and makes a probability table. If there are 4 instances of a number appearing in a column, the chance of that number appearing in each one is 0.25. Then, it checks the 3x3 grids and sees if those had probabilities that added up to 1. This also works checking probabilities for rows and boxes. This usually does not make a significant amount of changes on its own, but it also runs the basic solving algorithms after this process.

## Tier 3

Tier 3 utilizes more advanced solving practices, which is why this tier alone eliminates few potential solutions; this tier combined with tiers 1 and 2 can solve most hard sudoku puzzles. It goes through the subsections and looks at all combinations of 2 cells. It then checks if any of those combinations are a "pair". For example, if 2 cells in the same row can only have a 2 or a 4, then those are the only 2 cells that can contain that 2 or 4, and all other cells in that row cannot. It is unknown where the 2 and 4 could go, but what is known is that they can only go in one of those 2 cells. In other words, a set of 2 cells only has 2 numbers that can be placed. This code also checks combinations of 3 cells, and so on. After checking the different combinations of up to 7 cells, it moves on to the next row, and does the same process for columns and 3x3 grids.

## Tier 4

Tier 4 is done after all the other tiers were completed and the puzzle still is not solved. While other strategies can be done to eliminate potential solutions, many revolve around interactions between multiple rows, columns, or grids. At this stage, the number of potential boards is reasonably reduced. If a new board was made to chart every single possible solution, it would take a long time to check every single board for the correct answer. Instead, rows are put together, and those that are not compatible are eliminated. To start, the program looks at the first 2 rows, suppose the first row has 6 possibilities, and the second row has 18 possibilities. So, the number of possible ways to make a 2x9 board (knowing that the first row will always be the first row, and the second row will always be the second row, etc.) is 108 ways. The program goes through all those ways and creates those boards, then it checks them all to see which ones share numbers in the columns. For example, in the third space of both rows, these combined rows could both have an 8. If this happens, the board is eliminated, leaving behind only compatible boards. Then, the process repeats, taking these 2x9 boards and pasting all possible row 3's, and seeing if there are any conflicts in those columns. This process continues until the last row is complete, where there will likely be a list of possible boards. To save time, the program only checked for conflicts in the columns, and the rows are already fine since that is how they started. In the end, the program checks the 3x3 grids to see which one does not have a conflict. The one that does not have a conflict is saved and posted as the solution to the puzzle.
